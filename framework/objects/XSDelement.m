/*
 XSDelement.h
 The implementation of properties and methods for the XSDelement object.
 Generated by SudzC.com
 */
#import "XSDelement.h"
#import "XSDcomplexType.h"
#import "XSDschema.h"
#import "XMLUtils.h"

@interface XSDcomplexType (privateAccessors)
@property (strong, nonatomic) NSString *name;
@end

@interface XSDelement ()
@property (strong, nonatomic) XSDcomplexType* localComplexType;
@property (strong, nonatomic) NSString* name;
@property (strong, nonatomic) NSString* type;
@property (strong, nonatomic) NSString* substitutionGroup;
@property (strong, nonatomic) NSString* defaultValue;
@property (strong, nonatomic) NSString* fixed;
@property (strong, nonatomic) NSString* nillable;
@property (strong, nonatomic) NSString* abstractValue;
@property (strong, nonatomic) NSString* final;
@property (strong, nonatomic) NSString* block;
@property (strong, nonatomic) NSString* form;
@property (strong, nonatomic) NSNumber* minOccurs;
@property (strong, nonatomic) NSNumber* maxOccurs;
@end

@implementation XSDelement

- (id) initWithNode: (NSXMLElement*) node schema: (XSDschema*) schema {
    self = [super initWithNode:node schema:schema];
    if(self) {
        self.type = [XMLUtils node: node stringAttribute: @"type"];
        self.name = [XMLUtils node: node stringAttribute: @"name"];
        self.substitutionGroup = [XMLUtils node: node stringAttribute: @"substitutionGroup"];
        self.defaultValue = [XMLUtils node: node stringAttribute:  @"default"];
        self.fixed = [XMLUtils node: node stringAttribute: @"fixed"];
        self.nillable = [XMLUtils node: node stringAttribute: @"nillable"];
        self.abstractValue = [XMLUtils node: node stringAttribute: @"abstract"];
        self.final = [XMLUtils node: node stringAttribute: @"final"];
        self.block = [XMLUtils node: node stringAttribute: @"block"];
        self.form = [XMLUtils node: node stringAttribute: @"form"];
        
        NSNumberFormatter* numFormatter = [[NSNumberFormatter alloc] init];
        numFormatter.numberStyle = NSNumberFormatterDecimalStyle;
        
        NSString* minOccursValue = [XMLUtils node: node stringAttribute: @"minOccurs"];
        if(minOccursValue == nil) {
            self.minOccurs = [NSNumber numberWithInt: 1];
        } else if([minOccursValue isEqual: @"unbounded"]) {
            self.minOccurs = [NSNumber numberWithInt: -1];
        } else {
            self.minOccurs = [numFormatter numberFromString: minOccursValue];
        }
        NSString* maxOccursValue = [XMLUtils node: node stringAttribute: @"maxOccurs"];
        if(maxOccursValue == nil) {
            self.maxOccurs = [NSNumber numberWithInt: 1];
        } else if([maxOccursValue isEqual: @"unbounded"]) {
            self.maxOccurs = [NSNumber numberWithInt: -1];
        } else {
            self.maxOccurs = [numFormatter numberFromString: maxOccursValue];
        }
        
        if(self.type == nil) {
            NSXMLElement* complexTypeNode = [XMLUtils node: node childWithName: @"complexType"];
            if(complexTypeNode != nil) {
                self.localComplexType = [[XSDcomplexType alloc] initWithNode: complexTypeNode schema: schema];
                self.localComplexType.name = [self.name stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[self.name substringToIndex:1] uppercaseString]];
                [schema addType: self.localComplexType];
            }
        }
    }
    return self;
}

- (BOOL) hasComplexType {
    return (self.type != nil && [[self.schema typeForName:self.type] isKindOfClass:[XSDcomplexType class]]);
}

- (NSString*) objcType {
    NSString* rtn;
    if([self.name isEqualToString:@"bookCondition"]){
        NSLog(@"This is the match");
        NSLog(@"Stop here!");
    }
    if([self isSingleValue]) {
        if(self.type != nil) {
            id<XSType> type =[self.schema typeForName: self.type];
            rtn = [type targetClassName];
        } else {
            rtn = [self.localComplexType targetClassName];
        }
    } else {
        if(self.type != nil) {
            rtn = [[self.schema typeForName: self.type] arrayType];
        } else {
            rtn = self.localComplexType.arrayType;
        }
    }
    
    return rtn;
}

- (id<XSType>) schemaType {
    if(self.type != nil) {
        return [self.schema typeForName: self.type];
    } else {
        return self.localComplexType;
    }
}

- (NSString*) variableName {
    return [XSDschema variableNameFromName:self.name multiple:!self.isSingleValue];
}

- (NSString*) nameWithCapital {
    return [[self variableName] stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[self.name substringToIndex:1] uppercaseString]];
}

- (NSString*) readCodeForContent {
    if(self.localComplexType != nil) {
        return [self.localComplexType readCodeForElement: self];
    } else {
        return [[self.schema typeForName: self.type] readCodeForElement: self];
    }
}

- (BOOL) isSingleValue {
    return [self.maxOccurs intValue] >= 0 && [self.maxOccurs intValue] <= 1;
}

@end
