/*
 XSDcomplexType.h
 The implementation of properties and methods for the XSDcomplexType object.
 Generated by SudzC.com
 */
#import "XSDcomplexType.h"
#import "XSDexplicitGroup.h"
#import "XSDattribute.h"
#import "XSDelement.h"
#import "XSSimpleType.h"
#import "MGTemplateEngine.h"
#import "ICUTemplateMatcher.h"

@implementation XSDcomplexType

@synthesize name = _name;
@synthesize mixed;
@synthesize baseType = _baseType;
@synthesize sequenceOrChoice = _sequenceOrChoice;
@synthesize attributes = _attributes;
@synthesize globalElements;

- (id) init
{
    self = [super init];
    if(self)
    {
        self.name = nil; 
        self.mixed = nil; 
        self.sequenceOrChoice = nil;
        self.baseType = nil;
        self.attributes = nil;
        self.globalElements = [NSMutableArray array];
    }
    return self;
}

- (id) initWithNode: (NSXMLElement*) node schema: (XSDschema*) schema {
    if(node == nil || schema == nil) { return nil; }
    self = [super initWithSchema: schema];
    if(self) {
        engine = [MGTemplateEngine templateEngine];
        [engine setMatcher:[ICUTemplateMatcher matcherWithTemplateEngine:engine]];
        
        self.name = [XSSchemaNode node: node stringAttribute: @"name"];
        self.mixed = [XSSchemaNode node: node boolAttribute: @"mixed"];
        
        NSMutableArray* newAttributes = [NSMutableArray array];
        NSArray* attributeTags = [XSSchemaNode node: node childrenWithName: @"attribute"];
        for(NSXMLElement* anElement in attributeTags) {
            [newAttributes addObject: [[XSDattribute alloc] initWithNode: anElement schema: schema]];
        }
        self.attributes = newAttributes;
        
        NSXMLElement *child = [XSSchemaNode node: node childWithName: @"sequence"];
        if(!child) {
            child = [XSSchemaNode node: node childWithName: @"choice"];
        }
        if(child) {
            self.sequenceOrChoice = [[XSDexplicitGroup alloc] initWithNode: child schema: schema];
        }
        
        NSXMLElement* complexContent = [XSSchemaNode node: node childWithName: @"complexContent"];
        //if there is no complex content, there might still be simple content
        if(!complexContent) {
            complexContent = [XSSchemaNode node: node childWithName: @"simpleContent"];
        }
        
        NSArray* elementTags = [XSSchemaNode node: complexContent childrenWithName: @"extension"];
        for(NSXMLElement* anElement in elementTags) {
            self.baseType = [XSSchemaNode node: anElement stringAttribute: @"base"];

            child = [XSSchemaNode node: anElement childWithName: @"sequence"];
            if(!child) {
                child = [XSSchemaNode node: anElement childWithName: @"choice"];
            }
            if(child) {
                self.sequenceOrChoice = [[XSDexplicitGroup alloc] initWithNode: child schema: schema];
            }

            NSMutableArray* newAttributes = [NSMutableArray array];
            NSArray* attributeTags = [XSSchemaNode node: anElement childrenWithName: @"attribute"];
            for(NSXMLElement* anElement in attributeTags) {
                [newAttributes addObject: [[XSDattribute alloc] initWithNode: anElement schema: schema]];
            }
            self.attributes = newAttributes;
        }
        
    }
    return self;
}

- (NSArray*) elements {
    if(self.sequenceOrChoice != nil) {
        return self.sequenceOrChoice.elements;
    }
    return [NSArray array];
}

- (NSArray*) simpleTypesInUse {
    NSMutableSet* simpleTypes = [NSMutableSet set];
    
    for (XSDattribute *anAttr in self.attributes) {
        id type = [self.schema typeForName: anAttr.type];
        [simpleTypes addObject:type];
    }
    
    for (XSDelement* anElement in [self elements]) {
        id<XSType> aType = [self.schema typeForName: anElement.type];
        if([aType isKindOfClass: [XSSimpleType class]]) {
            [simpleTypes addObject: aType];
        }
    }
    
    //also add base type if needed
    id baseType = self.baseType;
    if(baseType != nil) {
        id<XSType> t = [self.schema typeForName: baseType];
        if(t != nil && [t isKindOfClass:[XSSimpleType class]]) {
            [simpleTypes addObject:t];
        }
    }
    
    return [simpleTypes allObjects];
}

- (NSArray*) complexTypesInUse {
    NSMutableSet* complexTypes = [NSMutableSet set];
    
    for (XSDelement* anElement in [self elements]) {
        if( anElement.localComplexType != nil) {
            [complexTypes addObject: anElement.localComplexType];
        } else {
            id<XSType> aType = [self.schema typeForName: anElement.type];
            if(aType!=self && [aType isKindOfClass: [XSDcomplexType class]]) {
                [complexTypes addObject: aType];
            }
        }
    }
    
    return [complexTypes allObjects];
}

- (NSString*) targetClassName {
    NSCharacterSet* illegalChars = [NSCharacterSet characterSetWithCharactersInString: @"-"];
    
    NSString* vName = [self.name stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[self.name substringToIndex:1] uppercaseString]];
    NSRange range = [vName rangeOfCharacterFromSet: illegalChars];
    while(range.length > 0) {
        // delete illegal char
        vName = [vName stringByReplacingCharactersInRange: range withString: @""];
        // range is now at next char
        vName = [vName stringByReplacingCharactersInRange: range withString:[[vName substringWithRange: range] uppercaseString]];
        
        range = [vName rangeOfCharacterFromSet: illegalChars];
    }
    
    NSString *prefix = [self.schema prefixForXMLPrefix:self.schema.classPrefix];
    return [NSString stringWithFormat: @"%@%@", prefix, vName];
}

- (NSString*) arrayType {
    return self.schema.complexTypeArrayType;
}

- (BOOL) hasSimpleBaseClass {
    id baseType = self.baseType;
    if(baseType != nil) {
        id<XSType> t = [self.schema typeForName: baseType];
        return t != nil && [t isKindOfClass:[XSSimpleType class]];
    }
    return NO;
}

- (BOOL) hasComplexBaseClass {
    id baseType = self.baseType;
    if(baseType != nil) {
        id<XSType> t = [self.schema typeForName: baseType];
        return [t isKindOfClass:[XSDcomplexType class]];
    }
    return NO;
}

- (NSString*) baseClassName {
    id baseType = self.baseType;
    if(baseType != nil) {
        return [[self.schema typeForName: baseType] targetClassName];
    } else {
        return @"";
    }
}

- (NSString*)readSimpleContent {
    id baseType = self.baseType;
    NSMutableString *str = [NSMutableString stringWithString:@""];
    if(baseType != nil) {
        XSSimpleType *stype = [self.schema typeForName: baseType];
        assert(stype);
        if(stype != nil && [stype isKindOfClass:[XSSimpleType class]]) {
            id substr = [stype readPrefixCode];
            if(substr)
                [str appendString:substr];
            
            if(str.length)
                [str appendString:@"\n"];
            
            substr = [stype readValueTemplate];
            if(substr)
                [str appendString:substr];
        }
        else
            [str appendString:@"/*called by mistake*/"]; //:/ ?
    }

    return str;
}

- (NSString*) readCodeForElement:(XSDelement *)element {
    NSDictionary* dict = [NSDictionary dictionaryWithObject: element forKey: @"element"];
    return [engine processTemplate: self.schema.readComplexTypeElementTemplate withVariables: dict];
}

- (NSString*) readCodeForAttribute:(XSDattribute *)attribute {
    return @"";
}

- (NSDictionary*) substitutionDict {
    return [NSDictionary dictionaryWithObject:self forKey:@"type"];
}

@end
